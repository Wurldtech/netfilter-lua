#!/usr/bin/env lua5.1
--[[
A conntracker wrapper using a pluggable queueing method and protocol decoder to set expectations.
Assumes iptables rules have been setup appropriately.
See ECHO.txt for usage.
]]

require"exptrack"

-- arguments

arg.method = "queue"
arg.decode = "echo"
arg.verbose = nil -- bool
arg.debug = nil -- bool
arg.expector = nil -- "external" or default

for i,a in ipairs(arg) do
    local s,e,k,v = a:find("^([^=]+)=(.*)$")
    arg[k] = v
end

if arg.verbose then
    exptrack.verbose = print
end
if arg.verbose == "very" then
    exptrack.debug = print
end

expector = {
    external = function (src, dst, sport, dport, expectport, timeout, flag)
        local ext = {
            "/usr/local/bin/nfct-expect-create-userspace",
            "expect="..expectport,
            "src="..src,
            "dst="..dst,
            "sport="..sport,
            "dport="..dport,
            "timeout="..timeout
        }
        if flag then
            table.insert(ext, "flag="..flag)
        end
        local cmd = table.concat(ext, " ")
        exptrack.debug("cmd=", cmd)
        exptrack.debug("ret=", os.execute(cmd))
    end;
}

method = {
    queue = {
        open = function()
            return exptrack.open(arg.queuenum)
        end;

        catch = exptrack.catch;
    };

    pcap = {
        open = function()
            return pcap.open_live(arg.ifx)
        end;

        catch = function(cap, decode)
            for capdata, timestamp, wirelen in cap.next, cap do
                decode(capdata)
            end
        end;
    };
}

arg.expector = expector[arg.expector]

exptrack.debug"debug output is on"
exptrack.verbose"verbose output is on"
exptrack.verbose("decode", arg.decode, "method", arg.method, "expector", arg.expector)

decoder = require(arg.decode)
catcher = method[arg.method]

c = catcher.open()
d = decoder.decode

catcher.catch(c, d)

