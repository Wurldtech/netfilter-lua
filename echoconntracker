#!/usr/bin/env lua5.1
--[[
A userspace connection tracker for an example RPC-like echo service.
Assumes iptables rules have been setup appropriately.
See ECHO.txt for usage.
]]

require"nfct"
require"nfq"
require"net"

local function debug(...) end
local function verbose(...) end

-- arguments

function usage(k)
    if arg[k] then
        return
    end
    print("arg '"..k.."' not provided")
    print("usage "..arg[0].." port=num [clear=y] [verbose=y|very]")
    os.exit(1)
end

for i,a in ipairs(arg) do
    local s,e,k,v = a:find("^([^=]+)=(.*)$")
    arg[k] = v
end

usage"port"

if arg.verbose then verbose = print end
if arg.verbose == "very" then
    debug = print
end

-- nfct helpers

local function ctprint(ct, name, ...)
    print("ct="..nfct.tostring(ct).." -- "..name, ...)
end

local function expprint(exp, name, ...)
    print("exp="..nfct.exp_tostring(exp).." -- "..name, ...)
end

local function check(...)
    if (...) then
        return ...
    end
    local _, emsg, eno = ...
    local emsg = "["..tostring(eno).."] "..tostring(emsg)
    return assert(_, emsg)
end

local function tuple(name, src, dst, sport, dport)
    local ct = assert(nfct.new())

    nfct.set_attr_pf(ct, "l3proto",  "inet")
    nfct.set_attr_ipv4(ct, "ipv4-src", src)
    nfct.set_attr_ipv4(ct, "ipv4-dst", dst)

    nfct.set_attr_ipproto(ct, "l4proto",  "tcp")

    if sport then
        nfct.set_attr_port(ct, "port-src", sport)
    end

    nfct.set_attr_port(ct, "port-dst", dport)

    ctprint(ct, name)

    return ct
end

local function expect(src, dst, sport, dport, expectport)
    -- identify the master to which this expectation is related
    local master = tuple("master", src, dst, sport, dport)
    local expected = tuple("expected", src, dst, nil, expectport)
    local mask = tuple("mask", 0xffffffff, 0xffffffff, nil, expectport)
    local timeout = 10 -- seconds FIXME we need this to be longer than the real server's timeout
    local exp = assert(nfct.exp_new(master, expected, mask, timeout, "permanent"))

    nfct.destroy(master)
    nfct.destroy(expected)
    nfct.destroy(mask)

    expprint(exp, "expectation")

    local h = assert(nfct.open("expect"))

    -- FIXME this can fail if conntrack hasn't tracked the master... but is that possible? we just
    -- got data from nfq, the connection must exist
    check(nfct.exp_query(h, "create", exp))

    nfct.exp_destroy(exp)

    nfct.close(h)
end

-- Expectation tracking

local qhandle = assert(nfq.open())

nfq.unbind_pf(qhandle, "inet")
nfq.bind_pf(qhandle, "inet")

local queue = assert(nfq.create_queue(qhandle, 0))

assert(nfq.set_mode(queue, "packet"))

local n = net.init()

nfq.catch(qhandle, function (nfqdata)
    debug("CB nfq")

    local inip = assert(nfq.get_payload(nfqdata))

    n:clear()
    n:decode_ip(inip)

    local _, tcp = pcall(n.get_tcp, n)
    local _, ip = pcall(n.get_ipv4, n)

    if not tcp or not ip then
        -- not of requested protocol
        debug("ignore protocol", n:dump())
        return "accept"
    end

    -- Original connection was client->server, and this packet is
    -- server->client, so reverse src and dst
    local src, dst, sport, dport = ip.dst, ip.src, tcp.dst, tcp.src
    local indata = tcp.payload

    if indata then
        debug("data", indata)
        local expectport = tonumber(indata)
        if expectport ~= nil then
            verbose("Q", "master", src, dst, sport, dport)
            verbose("Q", "expect", src, dst, "*", expectport)
            expect(src, dst, sport, dport, expectport)
        end 
    else
        debug("Q", "flags", string.format("%#x", tcp.flags), "(non-data)")
    end

    return "accept"
end)

